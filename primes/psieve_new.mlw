module PrimeNumberSieve

use import number.Divisibility
use import number.Prime
use import chan.PrototypeChan as Q
use import chan.Mem
use import promise.GlobalPromise as P
use import int.Int
use import int.ComputerDivision
use import ref.Ref

(*
// requires: cursor out = 0
// ensures [*]: ready => out
// ensures [out]: ready => out
// ensures [out]: forall i. 0 <= i < cursor out -> out[i] = init+1
func generate(init int, out chan<- int) {
	x := init
	for { 
		// invariant: forall i. 0 <= i < cursor out -> out[i] = init+i
		// invariant: cursor out + init = !x
		out <- x
		x++
	}
}
*)

predicate go_generate_init_req (ready: state) (init: int) (out: chan int)
  = cursor out = 0
predicate go_generate_init_inv (ready: state) (init: int) (out: chan int)
  = ready => out
predicate go_generate_req (ready: state) (init: int) (out: chan int) 
  = true
predicate go_generate_inv (ready: state) (init: int) (out: chan int) 
  = ready => out
   /\
    ( forall i. 0 <= i < cursor out -> out[i] = init+i )

val go_generate_1 (ready: state) (init: int) (out: chan int): unit
requires { "expl:go_generate_1" go_generate_req ready init out }
ensures  { go_generate_inv ready init out }
val go_generate_mk_1 (ready: state) (init: int) (out: chan int): unit
requires { "expl:go_generate_mk_1" go_generate_inv ready init out }
ensures  { go_generate_req ready init out }

val updP (): unit
writes { this }
reads { obligation }
ensures { forall q: chan 'a. (?obligation <-> handled q) -> (this => q) }

let generate (init: int) (out: chan int): unit
requires { go_generate_init_req this init out }
diverges
 = P.init();
   P.reachable (any bool ensures { result <-> handled out });
(*
   assume { this => out };
*)
updP();
assert { forall q: chan 'a. (?obligation <-> handled q) -> (this => q) };
assert { ?obligation <-> handled out };
assert { this => out };
   assert { go_generate_init_inv this init out };
   let x = ref init in
   while true do
      invariant { ?obligation <-> handled out }
      invariant { this => out }
      invariant { forall i. 0 <= i < cursor out -> out[i] = init+i }
      invariant { cursor out+init = !x }
      invariant { 0 <= out.pointer }
'Begin:
      send !x out this;
      P.reachable (any bool ensures { result <-> handled out });
      assume { this => out };
      go_generate_mk_1 this init out;
      x := !x+1;
      check { "expl:conditional variant decrease"
            not (at ?obligation) 'Begin ->
            0 <= at (0) 'Begin /\ (0) < at (0) 'Begin
        };
   done;
   check { ?obligation }

predicate go_sieve_init_req (ready: state) (src: chan int) (out: chan int)
  = cursor src = 0 /\ cursor out >= 0
predicate go_sieve_init_inv (ready: state) (src: chan int) (out: chan int)
  = ready => src
predicate go_sieve_req_1 (ready: state) (src: chan int) (out: chan int) (old_out: chan int)
  = (forall x: int. mem x src -> 2 <= x /\ forall d: int. 2 <= d -> divides d x -> mem d src)
predicate go_sieve_inv_1 (ready: state) (src: chan int) (out: chan int) (old_out: chan int)
  = ((exists x: int. mem x src /\ prime x /\ not mem_add x out old_out) -> ready => out)
  /\
    (not (exists x: int. mem x src /\ prime x /\ not mem_add x out old_out) -> ready => src)
predicate go_sieve_req_2 (ready: state) (src: chan int) (out: chan int) (old_out: chan int)
  = true
predicate go_sieve_inv_2 (ready: state) (src: chan int) (out: chan int) (old_out: chan int)
  = 
   (forall x: int. mem_add x out old_out -> mem x src /\ prime x)
(*
  /\
   (forall i j: int. 0 <= i < j < cursor out -> out[i] <> out[j])
*)
  /\
   ready => src
(*
  /\
   ((exists x: int. mem x src /\ prime x /\ not mem x out) -> ready => out)
*)

val go_sieve_1 (ready: state) (src: chan int) (out: chan int) (old_out: chan int): unit
requires { "expl:go_sieve_1" go_sieve_req_1 ready src out old_out }
ensures  { go_sieve_inv_1 ready src out old_out }
val go_sieve_mk_1 (ready: state) (src: chan int) (out: chan int) (old_out: chan int): unit
requires { "expl:go_sieve_mk_1" go_sieve_inv_1 ready src out old_out }
ensures  { go_sieve_req_1 ready src out old_out }
val go_sieve_2 (ready: state) (src: chan int) (out: chan int) (old_out: chan int): unit
requires { "expl:go_sieve_2" go_sieve_req_2 ready src out old_out }
ensures  { go_sieve_inv_2 ready src out old_out }
val go_sieve_mk_2 (ready: state) (src: chan int) (out: chan int) (old_out: chan int): unit
requires { "expl:go_sieve_mk_2" go_sieve_inv_2 ready src out old_out }
ensures  { go_sieve_req_2 ready src out old_out }

(*
func sieve(src <-chan int, out chan<- int) {
        p := <-src
        out <- p
        filt := make(chan int)
        go sieve(filt, out)
        for {
                n := <-src
                if n%p != 0 {
                        filt <- n
                }
        }
}
*)

let sieve (src: chan int) (out: chan int): unit
requires { go_sieve_init_req this src out }
diverges
  = 
'Entry:
    P.init();
    P.reachable (any bool ensures { result <-> handled src });
    assume { this => src };
    assert { go_sieve_init_inv this src out };
    let p = ref (recv src this) in
    P.reachable (any bool ensures { result <-> handled out });
    assume { this => out };
    assume { "expl:go_sieve_mk_1" go_sieve_req_1 this src out (at out 'Entry) };
    assert { prime !p };
    assert { "expl:go_sieve_mk_1" go_sieve_inv_1 this src out (at out 'Entry) };
    send !p out this;
    P.reachable (any bool ensures { result <-> handled src });
    assume { this => src };
    assume { "expl:go_sieve_mk_2" go_sieve_req_2 this src out (at out 'Entry) };
    assert { "expl:go_sieve_mk_2" go_sieve_inv_2 this src out (at out 'Entry) };
    let filt = make(): chan int in
    let go_sieve = any state in
    assert { go_sieve_init_req go_sieve filt out };
    assume { go_sieve_init_inv go_sieve filt out };
'Entry_go_sieve:
    while true do
      invariant { 0 <= src.pointer }
      invariant { 0 <= out.pointer }
      invariant { 0 <= filt.pointer }
      invariant { forall x: int. mem x filt -> mem x src /\ forall d: int. 2 <= d -> divides d x -> mem d filt }
      invariant { forall x: int. mem x src /\ not (divides !p x) <-> mem x filt }
      invariant { this => src }
      invariant { (exists x: int. mem x src /\ prime x /\ not mem_add x out (at out 'Entry)) -> this => out }
      invariant { not (exists x: int. mem x src /\ prime x /\ not mem_add x out (at out 'Entry)) -> this => src }
      invariant { (exists x: int. mem x filt /\ prime x /\ not mem_add x out (at out 'Entry_go_sieve)) -> go_sieve => out }
      invariant { not (exists x: int. mem x filt /\ prime x /\ not mem_add x out (at out 'Entry_go_sieve)) -> go_sieve => filt }
      invariant { ?obligation <-> handled src /\ ((exists x: int. mem x src /\ prime x /\ not mem_add x out (at out 'Entry)) -> handled out) }
      invariant { mem_add !p out (at out 'Entry) }
'Begin:
      abstract ensures { (exists x: int. mem x src /\ prime x /\ not mem_add x out (at out 'Entry)) ->  handled out }
           assume { go_sieve => out -> handled out };
      end;

      let n = ref (recv src this) in
      assume { this => src };
      P.reachable (any bool ensures { result <-> handled src });
      assume { (exists x: int. mem x src /\ prime x /\ not mem_add x out (at out 'Entry)) -> this => out };
      P.reachable (any bool ensures { result <-> (exists x: int. mem x src /\ prime x /\ not mem_add x out (at out 'Entry)) -> handled out });
      assume { "expl:go_sieve_mk_1" go_sieve_req_1 this src out (at out 'Entry) };
      assert { "expl:go_sieve_mk_1" go_sieve_inv_1 this src out (at out 'Entry) };
      if (mod !n !p <> 0) then (
        assert { forall x. mem x src /\ not (divides !p x) /\ x <> !n -> mem x filt };

        while not any bool ensures { result <-> go_sieve => filt } do
           invariant { 0 <= out.pointer }
           invariant { this => src }
           invariant { (exists x: int. mem x src /\ prime x /\ not mem_add x out (at out 'Entry)) -> this => out }
           invariant { not (exists x: int. mem x src /\ prime x /\ not mem_add x out (at out 'Entry)) -> this => src }
           invariant { ?obligation <-> handled src /\ ((exists x: int. mem x src /\ prime x /\ not mem_add x out (at out 'Entry)) -> handled out) }
           invariant { go_sieve => filt \/ go_sieve => out }
           invariant { go_sieve => filt \/ this => out }
           invariant { go_sieve => filt \/ at (cursor out) 'Begin+1 >= cursor out }
           variant { at (cursor out) 'Begin+1 - cursor out }
           invariant { mem_add !p out (at out 'Entry) }
           out[this <- go_sieve];
assume { this => src }; (* TODO *)
assume { (exists x: int. mem x src /\ prime x /\ not mem_add x out (at out 'Entry)) -> this => out };
P.reachable (any bool ensures { result <-> (exists x: int. mem x src /\ prime x /\ not mem_add x out (at out 'Entry)) -> handled out });
           assert { "expl:go_sieve_2" go_sieve_req_2 go_sieve filt out (at out 'Entry_go_sieve) };
           assume { "expl:go_sieve_2" go_sieve_inv_2 go_sieve filt out (at out 'Entry_go_sieve) };
           assume { "expl:go_sieve_mk_2" go_sieve_req_2 this src out (at out 'Entry) };
(* if we disable mem_add_R, this is necessary -- actually makes the proof go faster
assert { forall x. mem_add x out (at out 'Entry_go_sieve) -> mem_add x out (at out 'Entry) }; *)
           assert { "expl:go_sieve_mk_2" go_sieve_inv_2 this src out (at out 'Entry) };
        done;
(* TODO overrun *)

        send !n filt go_sieve;
        assert { "expl:go_sieve_1" go_sieve_req_1 go_sieve filt out (at out 'Entry_go_sieve) };
        assume { "expl:go_sieve_1" go_sieve_inv_1 go_sieve filt out (at out 'Entry_go_sieve) };
      );
      check { "expl:conditional variant decrease"
            not (at ?obligation) 'Begin ->
            0 <= at (0) 'Begin /\ (0) < at (0) 'Begin
        };
    done;
    check { ?obligation }


let lemma go_generator_inv_eq (s: state) (y x: int) (q: chan int)
requires { go_generate_inv s y q }
ensures { y <= x < cursor q+y <-> mem x q }
 = assert { y <= x < cursor q+y -> q[x-y] = x }

(*
func main() {
	outp := make(chan int)
	inp := make(chan int)
	go sieve(inp, outp)
	go generate(2, inp)
 	for {
		n := <-outp
	}
}
*)

use import infprime.NextPrime

let main (): unit
diverges
 = let outp = make(): chan int in
   let inp = make(): chan int in
   let go_sieve = any state in
   assert { go_sieve_init_req go_sieve inp outp };
   assume { go_sieve_init_inv go_sieve inp outp };
'Entry_go_sieve:
   let go_generate = any state in
   assert { go_generate_init_req go_generate 2 inp };
   assume { go_generate_init_inv go_generate 2 inp };
   while true do
     invariant { cursor inp >= 0 }
     invariant { cursor outp >= 0 }
     invariant { go_generate => inp }
     invariant { go_sieve => inp }
(* fwd-variant 1 *)
     invariant { forall x. mem x outp -> mem x inp }
'Fwd:
     while not any bool ensures { result <-> go_sieve => outp } do
       invariant { cursor inp >= 0 }
       invariant { cursor outp >= 0 }
       invariant { go_generate => inp }
       invariant { go_sieve => inp \/ go_sieve => outp }
   (* fwd-variant 1 *)
       invariant { forall x. mem x outp -> mem x inp }
       invariant { go_sieve => outp \/ inp[cursor inp-1] < at (some_larger_prime (inp[cursor inp-1])) 'Fwd }
       variant { at (some_larger_prime (inp[cursor inp-1])) 'Fwd - cursor inp }
'Begin:
       inp[go_sieve <- go_generate];
       go_generate_1 go_generate 2 inp;
       assert { "expl:go_sieve_2" go_sieve_req_1 go_sieve inp outp (at outp 'Entry_go_sieve) };
       assume { "expl:go_sieve_2" go_sieve_inv_1 go_sieve inp outp (at outp 'Entry_go_sieve)  };
   (* fwd-variant 1 *)
       assert { not mem inp[cursor inp-1] outp };                   (* ! *)
       assert { (prime inp[cursor inp-1]) -> go_sieve => outp };    (* ! *)
     done;
(* TODO overrun *)
     let n = recv outp go_sieve in
     assert { "expl:go_sieve_2" go_sieve_req_2 go_sieve inp outp (at outp 'Entry_go_sieve) };
     assume { "expl:go_sieve_2" go_sieve_inv_2 go_sieve inp outp (at outp 'Entry_go_sieve)  };
     assert { prime n };
   done

end
