module PrimeNumberSieve

use import number.Divisibility
use import number.Prime
use import chan.PrototypeChan as Q
use import promise.GlobalPromise as P
use import int.Int
use import ref.Ref

(*
// requires: cursor out = 0
// ensures [*]: ready => out
// ensures [out]: ready => out
// ensures [out]: forall i. 0 <= i < cursor out -> out[i] = init+1
func generate(init int, out chan<- int) {
	x := init
	for { 
		// invariant: forall i. 0 <= i < cursor out -> out[i] = init+i
		// invariant: cursor out + init = !x
		out <- x
		x++
	}
}
*)

predicate go_generate_init (ready: state) (init: int) (out: chan int)
  = ready => out
predicate go_generate_req (ready: state) (init: int) (out: chan int) 
  = true
predicate go_generate_inv (ready: state) (init: int) (out: chan int) 
  = ready => out
   /\
    ( forall i. 0 <= i < cursor out -> out[i] = init+i )

val go_generate (ready: state) (init: int) (out: chan int): unit
requires { "expl:go_generate_1" go_generate_req ready init out }
ensures  { go_generate_inv ready init out }
val go_generate_mk (ready: state) (init: int) (out: chan int): unit
requires { "expl:go_generate_1" go_generate_inv ready init out }
ensures  { go_generate_req ready init out }

let generate (init: int) (out: chan int): unit
requires { cursor out = 0 }
diverges
 = P.init();
   P.reachable (any bool ensures { result <-> handled out });
   assume { this => out };
   assert { go_generate_init this init out };
   let x = ref init in
   while true do
      invariant { ?obligation <-> handled out }
      invariant { this => out }
      invariant { forall i. 0 <= i < cursor out -> out[i] = init+i }
      invariant { cursor out+init = !x }
'Begin:
      send !x out this;
      P.reachable (any bool ensures { result <-> handled out });
      assume { this => out };
      go_generate_mk this init out;
      x := !x+1;
      check { "expl:conditional variant decrease"
            not (at ?obligation) 'Begin ->
            0 <= at (0) 'Begin /\ (0) < at (0) 'Begin
        };
   done;
   check { ?obligation }


(*
func main() {
	outp := make(chan int)
	inp := make(chan int)
	go sieve(inp, outp)
	go generate(inp)
	for {
		n := <-outp
	}
}
*)

end
