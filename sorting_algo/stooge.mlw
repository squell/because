module PermutFacts
  use import int.Int
  use import array.Array
  use import array.ArrayPermut
  use import array.ArrayEq

  lemma permut_identity:
    forall a b: array int, l u: int.
      0 <= l <= u <= length a -> array_eq a b -> permut_sub a b l u

  lemma permut_trans:
    forall a b c: array int, l u: int. 
      permut_sub a b l u /\ permut_sub b c l u -> permut_sub a c l u

  lemma permut_shrink:
    forall a b: array int, l u: int.
      0 < u /\ permut a b l u /\ a [u-1] = b[u-1] -> permut a b l (u-1)

  lemma permut_exch_trans_1:
    forall a b c: array int, l u i j: int.
      l <= i < u /\ l <= j < u /\
      permut_sub a b l u /\ exchange b c i j -> permut_sub a c l u

  lemma permut_exch_trans_2:
    forall a b c: array int, l u i j: int.
      l <= i < u /\ l <= j < u /\
      permut_sub a b l u /\ exchange a c i j -> permut_sub c b l u

end

(* Old Theory from why3 0.85, lifted to use the new parametrised version *)
theory NumOfParam

  type param

  use import int.Int

  predicate pr param int

  use int.NumOf

  function num_of (p : param) (a b : int) : int
    = NumOf.numof (pr p) a b
  (** number of [n] such that [a <= n < b] and [pr p n] *)

  lemma Num_of_empty :
    forall p : param, a b : int.
    b <= a -> num_of p a b = 0

  lemma Num_of_right_no_add :
    forall p : param, a b : int.
    a < b -> not (pr p (b-1)) -> num_of p a b = num_of p a (b-1)
  lemma Num_of_right_add :
    forall p : param, a b : int.
    a < b -> pr p (b-1) -> num_of p a b = 1 + num_of p a (b-1)

  lemma Num_of_bounds :
    forall p : param, a b : int. a < b -> 0 <= num_of p a b <= b - a
    (* direct when a>=b, by induction on b when a <= b *)

  lemma Num_of_append :
    forall p : param, a b c : int.
    a <= b <= c -> num_of p a c = num_of p a b + num_of p b c
    (* by induction on c *)

  lemma Num_of_left_no_add :
    forall p : param, a b : int.
    a < b -> not pr p a -> num_of p a b = num_of p (a+1) b
    (* by Num_of_append *)
  lemma Num_of_left_add :
    forall p : param, a b : int.
    a < b -> pr p a -> num_of p a b = 1 + num_of p (a+1) b
    (* by Num_of_append *)

  lemma Empty :
    forall p : param, a b : int.
    (forall n : int. a <= n < b -> not pr p n) -> num_of p a b = 0
    (* by induction on b *)

  lemma Full :
    forall p : param, a b : int. a <= b ->
    (forall n : int. a <= n < b -> pr p n) -> num_of p a b = b - a
    (* by induction on b *)

  lemma num_of_increasing:
    forall p : param, i j k : int.
    i <= j <= k -> num_of p i j <= num_of p i k
    (* by Num_of_append and Num_of_non_negative *)

  lemma num_of_strictly_increasing:
    forall p: param, i j k l: int.
    i <= j <= k < l -> pr p k -> num_of p i j < num_of p i l
    (* by Num_of_append and num_of_increasing *)

  lemma num_of_change_any:
    forall p1 p2: param, a b: int.
    (forall j: int. a <= j < b -> pr p1 j -> pr p2 j) ->
    num_of p2 a b >= num_of p1 a b

  lemma num_of_change_some:
    forall p1 p2: param, a b i: int. a <= i < b ->
    (forall j: int. a <= j < b -> pr p1 j -> pr p2 j) ->
    not (pr p1 i) -> pr p2 i ->
    num_of p2 a b > num_of p1 a b

end

module StoogeSort

  use import int.Int
  use import int.ComputerDivision
  use import ref.Ref
  use import array.Array
  use import array.ArraySwap
  use import array.ArrayPermut
  use import array.ArrayEq
  use import map.Occ
  use import PermutFacts

  predicate mislocated (p: (array int,int,int)) (x: int) = let (a,i,j) = p in 
    exists y: int. i <= y < j /\ a[x] < a[y]

  clone import NumOfParam with type param = (array int,int,int), predicate pr = mislocated
(*
  use import int.NumOf
  function num_of (p: (array int,int,int)): int->int->int = NumOf.numof (mislocated p)
*)

  lemma exists_num_of_pre_0:
    forall a: array int, l u p q: int.
      num_of (a,p,q) l u = 0 -> forall i: int. l <= i < u -> not mislocated (a,p,q) i

  lemma exists_num_of_pre_1:
    forall a: array int, l u p q: int.
      num_of (a,p,q) l u = 0 -> forall j: int. l <= j < u -> not exists i: int. p <= i < q /\ a[i] > a[j]

(* only slight improvements to verification speed, or may even be detrimental

  lemma all_num_of:
    forall a: array int, l u p q: int.
      l <= u /\ (forall i: int. l <= i < u -> mislocated (a,p,q) i) -> num_of (a,p,q) l u = u-l 

  lemma exists_num_of:
    forall a: array int, l u p q: int.
      num_of (a,p,q) l u = 0 -> forall i j: int. p <= i < q /\ l <= j < u -> a[i] <= a[j]

  lemma permut_mislocated_left:
    forall a1 a2: array int, i p q: int.
      not (p <= i < q)/\ permut_sub a1 a2 p q /\ a1[i] = a2[i] -> 
      mislocated (a2,p,q) i -> mislocated (a1,p,q) i
*)

  lemma permut_num_of_left_weak:
    forall a1 a2: array int, l u p q: int.
      0 <= p <= q <= l <= u <= length a1 /\ permut_sub a1 a2 p q -> 
      num_of (a2,p,q) l u <= num_of (a1,p,q) l u

(*
  lemma permut_num_of_left_weak_2:
    forall a1 a2: array int, l u p q: int.
      0 <= p <= q <= l <= u <= length a1 /\ permut_sub a1 a2 p q -> 
      num_of (a2,p,q) l u >= num_of (a1,p,q) l u

  lemma permut_num_of_left:
    forall a1 a2: array int, l u p q: int.
      0 <= p <= q <= l <= u <= length a1 /\ permut_sub a1 a2 p q -> 
      num_of (a1,p,q) l u = num_of (a2,p,q) l u
*)

  let find_member (a: array int) (e: int) (l u: int): int
  requires { exists i: int. 0 <= l <= i < u <= length a /\ a[i] = e }
  ensures { l <= result < u }
  ensures { a[result] = e }
  = let pos = ref (l-1) in
    for i = l to u-1 do
      invariant { l-1 <= !pos < u }
      invariant { !pos >= l -> a[!pos] = e }
      invariant { !pos < l -> not exists j: int. l <= j < i /\ a[j] = e }
      if a[i] = e then pos := i
    done; !pos

  lemma array_eq_num_of:
    forall a1 a2: array int, l u p q: int.
      0 <= p <= q <= l <= u <= length a1 = length a2 /\ 
      array_eq_sub a1 a2 l u /\ array_eq_sub a1 a2 p q -> 
      num_of (a1,p,q) l u = num_of (a2,p,q) l u

  let lemma exchange_num_of_weak (a1 a2: array int) (l u p q: int): unit
  requires { 0 <= p <= q <= l <= u < length a1 = length a2 }
  requires { exchange a1 a2 l u }
  ensures { num_of (a1,p,q) l (u+1) = num_of (a2,p,q) l (u+1) }
  =  if l < u then (
      assert { array_eq_sub a1 a2 (l+1) u };
      assert { array_eq_sub a1 a2 p q };
      assert { mislocated (a1,p,q) l <-> mislocated (a2,p,q) u };
      assert { mislocated (a1,p,q) u <-> mislocated (a2,p,q) l };
(*
      check  { num_of (a1,p,q) l (l+1) = num_of (a2,p,q) u (u+1) };
      check  { num_of (a2,p,q) l (l+1) = num_of (a1,p,q) u (u+1) };
      check  { num_of (a1,p,q) (l+1) u = num_of (a2,p,q) (l+1) u };
      check  { num_of (a1,p,q) l u     = num_of (a1,p,q) l (l+1) + num_of (a1,p,q) (l+1) u
                                       = num_of (a2,p,q) u (u+1) + num_of (a2,p,q) (l+1) u (* + num_of(a2,p,q) u (u+1) }; *) };
      check  { num_of (a1,p,q) l (u+1) = num_of (a1,p,q) l (l+1) + num_of (a1,p,q) (l+1) u + num_of (a1,p,q) u (u+1) 
                                       = num_of (a2,p,q) l (l+1) + num_of (a2,p,q) (l+1) u + num_of (a2,p,q) u (u+1) }
*)
    )

  let lemma exchange_num_of (a1 a2: array int) (l u p q i j: int): unit
  requires { 0 <= p <= q <= l <= i <= j < u <= length a1 = length a2 }
  requires { exchange a1 a2 i j }
  ensures { num_of (a2,p,q) l u = num_of (a1,p,q) l u }
  = assert { array_eq_sub a1 a2 l i };
    assert { array_eq_sub a1 a2 (j+1) u };
    assert { array_eq_sub a1 a2 p q };
    assert { num_of (a2,p,q) l u = num_of (a2,p,q) l i + num_of (a2,p,q) i (j+1) + num_of (a2,p,q) (j+1) u 
                                 = num_of (a1,p,q) l i + num_of (a1,p,q) i (j+1) + num_of (a1,p,q) (j+1) u }

  let lemma permut_num_of_right_weak (a1 a2: array int) (l u p q: int): unit
  requires { 0 <= p <= q <= l <= u <= length a1 }
  requires { permut_sub a1 a2 l u }
  ensures { num_of (a2,p,q) l u <= num_of (a1,p,q) l u }
  = let b2 = copy a1 in
    assert { permut_sub a1 b2 p q };
    assert { permut_sub a1 b2 l u };
    for i = u-1 downto l do
      invariant { num_of (b2,p,q) l u <= num_of (a1,p,q) l u }
      invariant { permut_sub b2 a2 l (i+1) }
      let x = find_member b2 a2[i] l (i+1) in
      swap b2 x i;
    done;
    assert { permut_sub b2 a2 p q }

(*
  goal permut_num_of_right_weak:
    forall a1 a2: array int, l u p q: int.
      0 <= p <= q <= l <= u <= length a1 /\ permut_sub a1 a2 l u -> 
      num_of (a2,p,q) l u <= num_of (a1,p,q) l u

  lemma permut_num_of_right_weak_2:
    forall a1 a2: array int, l u p q: int.
      0 <= p <= q <= l <= u <= length a1 /\ permut_sub a1 a2 l u -> 
      num_of (a2,p,q) l u >= num_of (a1,p,q) l u

  lemma permut_num_of_right:
    forall a1 a2: array int, l u p q: int.
      0 <= p <= q <= l <= u <= length a1 /\ permut_sub a1 a2 l u -> 
      num_of (a1,p,q) l u = num_of (a2,p,q) l u

*)

  let rec stoogesort (a: array int) (first limit: int): unit
  variant { limit - first }
  requires { 0 <= first < limit <= length a }
  ensures { permut_sub (old a) a first limit }
  ensures { forall i j: int. first <= i <= j < limit -> a[i] <= a[j] }
  = 'Start:
    if a[first] > a[limit-1] then
      swap a first (limit-1);
    if limit - first > 2 then (
      let t = div (limit - first) 3 in

      'X: stoogesort a first (limit - t);
      assert { num_of (a,first,first+t) (limit-t) limit <= t };
      assert { num_of (a,first,first+t) (first+t) (limit-t) = 0 };
      assert { num_of (a,first,first+t) (first+t) limit <= t };
      'Y: stoogesort a (first+t) limit;
      assert { num_of (a,first,first+t) (first+t) limit <= t };
      assert { num_of (a,first+t,limit-t) (limit-t) limit = 0 };
      assert { num_of (a,first,first+t) (limit-t) limit > 0 -> num_of (a,first,first+t) (first+t) (limit-t) = limit-t-(first+t) };
      assert { num_of (a,first,first+t) (limit-t) limit = 0 };
      assert { num_of (a,first,limit-t) (limit-t) limit = 0 };
      'Z: stoogesort a first (limit - t);
      assert { num_of (a,first,limit-t) (limit-t) limit = 0 };
      assert { forall i j: int. limit-t <= i <= j < limit -> a[i] <= a[j] };

      assert { permut_sub (at a 'Start) (at a 'X) first limit };
      assert { permut_sub (at a 'X) (at a 'Y) first limit };
      assert { permut_sub (at a 'Y) (at a 'Z) first limit };
      assert { permut_sub (at a 'Z) a first limit };
    )

  let sort (a: array int): unit
  ensures { forall i j: int. 0 <= i <= j < length a -> a[i] <= a[j] }
  ensures { permut_all (old a) a }
  = if length a > 0 then stoogesort a 0 (length a)

end
