module TickCounter

use import int.Int
use import ref.Ref

val ghost ticks: ref int

let ghost tick (): unit
writes { ticks }
ensures { !ticks = old (!ticks) + 1 }
 = ticks := !ticks + 1

end

module Promise

use import int.Int

type obligation

function timeout obligation: int

predicate satisfied obligation

val promise (t: int): obligation
requires { t >= 0 }
ensures { timeout result >= t }

val satisfy (o: obligation): unit
ensures { satisfied o }

end

module PromiseMore

use import int.Int
use import Promise as P

type obligation model { mutable obl: P.obligation }

function timeout (x: obligation): int = P.timeout x.obl
predicate satisfied (x: obligation) = P.satisfied x.obl

val promise (t: int): obligation
requires { t >= 0 }
ensures { timeout result >= t }

val satisfy (o: obligation): unit
writes { o.obl }
ensures { satisfied (old o) }
ensures { timeout o >= timeout (old o) }

end

module Test

use import PromiseMore
use import int.Int
use import ref.Ref
use HighOrd as HO

predicate mooi int
axiom mooi_partialdef: forall i. exists j. i <= j < i+7 /\ mooi j
lemma mooi_1_to_7: exists i. 1 <= i < 8 /\ mooi i

let test_reach () =
    let reachme = any obligation in
'L:
    let y = ref 1 in
    for x = 1 to 10000000 do
        invariant { (exists y. 1 <= y < x /\ mooi y) -> satisfied (at reachme 'L) }
        invariant { reachme = (at reachme 'L) \/ satisfied (at reachme 'L) }
        invariant { !y <= x }
        (* pseudovariant { 100 - !y } { satisfied (at reachme 'L) } *)
'B:
        if mooi x then (
            satisfy reachme
        );
        y := !y + 1;
        assert { "expl:conditional decrease" not (at (satisfied (at reachme 'L)) 'B) -> 0 <= (100- !y) < (at (100- !y) 'B) };
    done;
    check { satisfied (at reachme 'L) }

end
