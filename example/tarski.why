theory Collection

use import set.SetComprehension

function intersection (fam: set (set 'a)): set 'a
  = comprehension (\x: 'a. forall y:set 'a. mem y fam -> mem x y)

lemma intersection_common_subset:
  forall fam: set (set 'a).
    forall x: set 'a. mem x fam -> subset (intersection fam) x

lemma intersection_greatest_common_subset:
  forall fam: set (set 'a),  s: set 'a.
    (forall x: set 'a. mem x fam -> subset s x) -> subset s (intersection fam)

(*
function union (fam: set (set 'a)): set 'a
  = comprehension (\x. exists y. mem y fam /\ mem x y)

lemma union_common_superset:
  forall fam: set (set 'a).
    forall x. mem x fam -> subset x (union fam)

lemma union_least_common_superset:
  forall fam: set (set 'a), s.
    (forall x. mem x fam -> subset x s) -> subset (union fam) s
*)

end

theory Tarski

type t

use import set.SetComprehension
use import Collection

function f (set t): set t

axiom f_is_monotonic:
  forall x y: set t. subset x y -> subset (f x) (f y)

constant prefixpoints: set (set t) = 
  comprehension (\x: set t. subset (f x) x)

constant mu: set t = intersection prefixpoints

lemma fmu_subset_of_mu:
  subset (f mu) mu

lemma fmu_equiv_of_mu:
  f mu == mu

lemma mu_is_fixpoint:
  f mu = mu

goal fixpoint: exists x:set t. f x = x

end
