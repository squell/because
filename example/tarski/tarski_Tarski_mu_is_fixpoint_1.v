(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require set.Set.

Axiom t : Type.
Parameter t_WhyType : WhyType t.
Existing Instance t_WhyType.

Parameter comprehension: forall {a:Type} {a_WT:WhyType a}, (a -> bool) ->
  (set.Set.set a).

Axiom comprehension_def : forall {a:Type} {a_WT:WhyType a}, forall (p:(a ->
  bool)), forall (x:a), (set.Set.mem x (comprehension p)) <-> ((p x) = true).

Parameter filter: forall {a:Type} {a_WT:WhyType a}, (a -> bool) ->
  (set.Set.set a) -> (set.Set.set a).

Parameter fc: forall {a:Type} {a_WT:WhyType a}, (a -> bool) -> (set.Set.set
  a) -> (a -> bool).

Axiom fc_def : forall {a:Type} {a_WT:WhyType a}, forall (p:(a -> bool))
  (u:(set.Set.set a)) (x:a), (((fc p u) x) = true) <-> (((p x) = true) /\
  (set.Set.mem x u)).

Axiom filter_def : forall {a:Type} {a_WT:WhyType a}, forall (p:(a -> bool))
  (u:(set.Set.set a)), ((filter p u) = (comprehension (fc p u))).

Parameter map: forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  (a -> b) -> (set.Set.set a) -> (set.Set.set b).

Parameter fc1: forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  (a -> b) -> (set.Set.set a) -> (b -> bool).

Axiom fc_def1 : forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(a -> b)) (u:(set.Set.set a)) (y:b), (((fc1 f u) y) = true) <->
  exists x:a, (set.Set.mem x u) /\ (y = (f x)).

Axiom map_def : forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(a -> b)) (u:(set.Set.set a)), ((map f u) = (comprehension (fc1 f
  u))).

Axiom map_def1 : forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(a -> b)) (u:(set.Set.set a)), forall (x:a), (set.Set.mem x u) ->
  (set.Set.mem (f x) (map f u)).

Parameter intersection: forall {a:Type} {a_WT:WhyType a}, (set.Set.set
  (set.Set.set a)) -> (set.Set.set a).

Parameter fc2: forall {a:Type} {a_WT:WhyType a}, (set.Set.set (set.Set.set
  a)) -> (a -> bool).

Axiom fc_def2 : forall {a:Type} {a_WT:WhyType a}, forall (fam:(set.Set.set
  (set.Set.set a))) (x:a), (((fc2 fam) x) = true) <-> forall (y:(set.Set.set
  a)), (set.Set.mem y fam) -> (set.Set.mem x y).

Axiom intersection_def : forall {a:Type} {a_WT:WhyType a},
  forall (fam:(set.Set.set (set.Set.set a))),
  ((intersection fam) = (comprehension (fc2 fam))).

Axiom intersection_common_subset : forall {a:Type} {a_WT:WhyType a},
  forall (fam:(set.Set.set (set.Set.set a))), forall (x:(set.Set.set a)),
  (set.Set.mem x fam) -> (set.Set.subset (intersection fam) x).

Axiom intersection_greatest_common_subset : forall {a:Type} {a_WT:WhyType a},
  forall (fam:(set.Set.set (set.Set.set a))) (s:(set.Set.set a)),
  (forall (x:(set.Set.set a)), (set.Set.mem x fam) -> (set.Set.subset s
  x)) -> (set.Set.subset s (intersection fam)).

Parameter f: (set.Set.set t) -> (set.Set.set t).

Axiom f_is_monotonic : forall (x:(set.Set.set t)) (y:(set.Set.set t)),
  (set.Set.subset x y) -> (set.Set.subset (f x) (f y)).

Parameter prefixpoints: (set.Set.set (set.Set.set t)).

Parameter fc3: ((set.Set.set t) -> bool).

Axiom fc_def3 : forall (x:(set.Set.set t)), ((fc3 x) = true) <->
  (set.Set.subset (f x) x).

Axiom prefixpoints_def : (prefixpoints = (comprehension fc3)).

Parameter mu: (set.Set.set t).

Axiom mu_def : (mu = (intersection prefixpoints)).

Axiom fmu_subset_of_mu : (set.Set.subset (f mu) mu).

Axiom fmu_equiv_of_mu : (set.Set.infix_eqeq (f mu) mu).

(* Why3 goal *)
Theorem mu_is_fixpoint : ((f mu) = mu).
apply set.Set.extensionality.
apply fmu_equiv_of_mu.
Qed.

